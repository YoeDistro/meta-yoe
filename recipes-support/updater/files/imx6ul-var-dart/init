#!/bin/sh

# MTD partitions
#Device       Name      Start    Size(B)  Size(MiB)  Size(Blks)
#mtd0        spl        0x0   0x200000          2          16
#mtd1      uboot   0x200000   0x200000          2          16
#mtd2  uboot env   0x400000   0x200000          2          16
#mtd3      linux   0x600000   0xc00000         12          96
#mtd4     rootfs  0x1200000  0x2d00000         45         360
#mtd5       data  0x3f00000  0x4100000         65         520
#total size = 0x8000000, 128MiB

# Prints information
msg() {
  echo "$@" >/dev/console
}

UPDATER_VERSION="62"

BOOT="mtd1"
KERNEL="mtd3"
ROOTFS="mtd4"
DATAPART="mtd5"
ROOTFS_MOUNT="/root"

MTD_ROOTFS=4
MTD_DATA=5

init_gpio() {
  # turn on Audio amp
  echo 18 >/sys/class/gpio/export
  echo out >/sys/class/gpio/gpio18/direction
  echo 1 >/sys/class/gpio/gpio18/value
}

# populate bootparam environment
populate_bootparams() {
  for p in $(cat /proc/cmdline); do
    opt=$(echo $p | cut -d'=' -f1)
    opt=$(echo $opt | tr '.-' '__')
    if [ "$(echo $p | cut -d'=' -f1)" = "$p" ]; then
      eval "bootparam_${opt}=true"
    else
      value="$(echo $p | cut -d'=' -f2-)"
      eval "bootparam_${opt}=\"${value}\""
    fi
  done
}

format_data_partition() {
  msg "format_data"
  ubidetach -m $MTD_DATA 2>/dev/null
  flash_eraseall /dev/mtd$MTD_DATA
  if ! ubiattach -m $MTD_DATA; then
    msg "Error attaching to MTD data"
    return 1
  fi

  ubimkvol /dev/ubi1 -N ubidata -m || return 1
}

mount_data() {
  DATA_MOUNT_POINT=/data

  msg "mounting data partition"
  mkdir -p $DATA_MOUNT_POINT
  if ! mount -t ubifs ubi1:ubidata $DATA_MOUNT_POINT; then
    msg "data partition mount failed, formatting"
    format_data_partition
    if ! mount -t ubifs ubi1:ubidata $DATA_MOUNT_POINT; then
      msg "data partition mount after format failed, bailing"
      espeak "updater, data partition error, please service unit"
      return 1
    fi
  fi

  mkdir -p $DATA_MOUNT_POINT/log

  msg "data partition mounted"

  return 0
}

update_uboot() {
  if [ -e u-boot.img ]; then
    msg "checking if u-boot needs updated"
    SIZE=$(stat -c%s u-boot.img)
    nanddump -l $SIZE -f uboot.dump /dev/$BOOT || return 1
    dd if=uboot.dump of=uboot.dump2 bs=$SIZE count=1
    if ! diff u-boot.img uboot.dump2 2>/dev/null; then
      msg "updating uboot"
      flash_eraseall /dev/$BOOT
      nandwrite -p /dev/$BOOT u-boot.img
      boot_updated=1
    else
      msg "u-boot is up to date"
    fi
    rm uboot.dump
    rm uboot.dump2
  fi
}

update_kernel() {
  kernel_needs_update=0

  if [ -e zImage ]; then
    msg "checking if kernel needs to be updated"
    SIZE=$(stat -c%s zImage)
    nanddump -l $SIZE -f zImage.dump /dev/$KERNEL || return 1
    dd if=zImage.dump of=zImage.dump2 bs=$SIZE count=1
    if ! diff zImage zImage.dump2 2>/dev/null; then
      msg "zImage needs updated"
      kernel_needs_update=1
    else
      msg "kernel is up to date"
    fi
    rm zImage.dump
    rm zImage.dump2
  fi

  if dmesg | grep "Machine.*ULL"; then
    DTB_FILE=zImage-ull.dtb
  else
    DTB_FILE=zImage.dtb
  fi

  if [ -e $DTB_FILE ]; then
    msg "checking if dtb needs to be updated"
    SIZE=$(stat -c%s $DTB_FILE)
    nanddump -s 0xbe0000 -l $SIZE -f dtb.dump /dev/$KERNEL || return 1
    dd if=dtb.dump of=dtb.dump2 bs=$SIZE count=1
    if ! diff $DTB_FILE dtb.dump2 2>/dev/null; then
      msg "dtb needs updated"
      kernel_needs_update=1
    else
      msg "dtb is up to date"
    fi
    rm dtb.dump
    rm dtb.dump2
  fi

  if [ "$kernel_needs_update" = "1" ]; then
    msg "updating kernel image"
    msg "DTB: $DTB_FILE"
    flash_eraseall /dev/$KERNEL || return 1
    msg "writing zImage"
    nandwrite -p /dev/$KERNEL zImage || return 1
    msg "writing dtb"
    nandwrite -p -s 0xbe0000 /dev/$KERNEL $DTB_FILE || return 1
    msg "kernel update complete"
    boot_updated=1
  fi

  msg "Returning from update_kernel, boot_update=$boot_updated"

  return 0
}

update_rootfs() {
  if [ -e rootfs.ubi ]; then
    msg "Writing new rootfs image, please wait ..."
    ubidetach -m $MTD_ROOTFS 2>/dev/null
    flash_eraseall /dev/$ROOTFS || return 1
    ubiformat /dev/$ROOTFS -f rootfs.ubi -s 2048 -O 2048
    msg "Rootfs update complete"
  fi
  return 0
}

process_update() {
  UPDATE_FILE=$1
  if ! tar -C /tmp -xf $UPDATE_FILE; then
    msg "Failed to extract update image"
    return 1
  fi

  cd /tmp
  if ! md5sum -c update.md5; then
    msg "Error: checksum error in update file"
    return 1
  else
    espeak "updating system"
    boot_updated=0
    update_uboot || return 1
    update_kernel || return 1

    if [ "$boot_updated" = "1" ]; then
      msg "Boot components updated, rebooting ..."
      espeak "rebooting"
      reboot -f
    fi

    update_rootfs || return 1

    cp version.txt /data/
  fi
  cd /
  # wait for user to remove USB flash disk
  # not doing this for now
  # while [ -e /sys/class/scsi_disk/* ]; do sleep 1; done

  espeak "update complete"
  return 0
}

initialize() {
  msg "============================================================"
  msg "Updater version $UPDATER_VERSION"

  mount -t devtmpfs none /dev
  mount -t sysfs sysfs /sys
  mount -t proc proc /proc

  init_gpio

  # attach MTD partitions first so they are always in the right order
  ubiattach -m $MTD_ROOTFS
  ubiattach -m $MTD_DATA

  msg "Sleeping for 3 second(s) for USB flash to settle..."
  sleep 3

  espeak "point watch dart, updater version $UPDATER_VERSION"

  mkdir -p /usb
  mkdir -p /data
}

mount_usb() {
  if mount /dev/sda1 /usb 2>/dev/null; then
    usb_mounted=1
    msg 'found disk at /dev/sda1'
    return 0
  fi

  if [ "$usb_mounted" = "0" ]; then
    if mount /dev/sda /usb 2>/dev/null; then
      usb_mounted=1
      msg 'found disk at /dev/sda'
      return 0
    fi
  fi

  return 1
}

mount_sd_boot() {
  if mount /dev/mmcblk0p1 /boot 2>/dev/null; then
    msg 'found sd boot partition'
    return 0
  fi

  return 1
}

umount_usb() {
  if mount | grep usb; then
    umount /usb
  fi

  return 0
}

# searches for update*.pwu and update*.img files
# and then uses the newest version file it finds
# also supports the legacy update.img format for now

find_update_file() {
  DIR=$1
  cd $DIR
  extensions="pwu img"
  update=""
  for ext in $extensions; do
    update=$(echo $(ls update_dart*.${ext} -v -r 2>/dev/null) | sed "s/update.${ext}//" | sed "s/${ext}.*/${ext}/" | sed "s/^\s*//")
    if echo $update | grep update >/dev/null; then
      echo $update
      break
    fi
  done

  if [ "${update}" = "" ]; then
    if [ -e update.img ]; then
      echo update.img
    fi
  fi
  cd - >/dev/null
}

update_from_usb() {
  espeak "updater, found u s b disk"
  update_file=$(find_update_file /usb)
  if echo $update_file | grep update; then
    msg "Found update image file on USB disk: $update_file"
    if ! process_update /usb/$update_file; then
      msg "Failed to process update from USB"
      espeak "updater, failed to process update from u s b"
      return 1
    else
      msg "Update from USB complete"
      return 0
    fi
  fi

  return 1
}

update_from_sd() {
  update_file=$(find_update_file /boot)
  if echo $update_file | grep update; then
    msg "Found update image file on SD disk: $update_file"
    if ! process_update /boot/$update_file; then
      msg "Failed to process update from SD"
      espeak "updater, failed to process update from s d"
      return 1
    else
      msg "Update from SD complete"
      espeak "update from s d complete, please remove s d card and cycle power"
      sleep 9999d
    fi
  fi
  return 1
}

update_from_data() {
  update_file=$(find_update_file /data/update)
  if echo $update_file | grep update; then
    msg "Found update on data partition: $update_file"
    if ! process_update /data/update/$update_file; then
      msg "Failed to process update from nand"
      espeak "updater, failed to process update from nand"
    else
      msg "Update from nand complete"
    fi

    msg "Removing update files from data partition"
    rm /data/update/*
  fi
}

#unmount_usb() {
#}

mount_rootfs_sd() {
  if ! mount /dev/mmcblk0p2 $ROOTFS_MOUNT; then
    msg "Error mount SD rootfs, please fix ..."
    espeak "updater, S D file system error"
    sleep 9999d
  fi

  mkdir -p $ROOTFS_MOUNT/media/boot
  mount --move /boot $ROOTFS_MOUNT/media/boot
}

mount_rootfs_nand() {
  # may be attached by kernel on boot, but we have
  # this here in case we programmed the rootfs
  ubiattach -m $MTD_ROOTFS

  if ! mount -tubifs ubi0:rootfs $ROOTFS_MOUNT; then
    msg "Error mounting nand rootfs, please fix ..."
    espeak "updater, root f s file system error, please service unit"
    sleep 9999d
  fi
}

boot() {
  mkdir -p $ROOTFS_MOUNT

  if [ -e /dev/mmcblk0p1 ]; then
    msg "Booting from SD ..."
    espeak "booting system from S D"
    mount_rootfs_sd
  else
    msg "Booting from NAND ..."
    espeak "booting system"
    mount_rootfs_nand
  fi

  umount_usb

  msg "Moving filesystems into rootfs..."
  mkdir -p $ROOTFS_MOUNT/media/data
  mount --move /data $ROOTFS_MOUNT/media/data
  mount --move /dev $ROOTFS_MOUNT/dev
  mount --move /proc $ROOTFS_MOUNT/proc
  mount --move /sys $ROOTFS_MOUNT/sys

  msg "switching root filesystem"

  exec switch_root -c /dev/console $ROOTFS_MOUNT /sbin/init 5
}

update() {
  # update precedence usb, SD, data partition
  msg "checking usb ..."
  if ! (mount_usb && update_from_usb); then
    msg "checking sd ..."
    if ! (mount_sd_boot && update_from_sd); then
      msg "checking data ..."
      update_from_data
    fi
  fi
}

initialize
mount_data
update
boot
